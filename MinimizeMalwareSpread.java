import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;

public class MinimizeMalwareSpread {

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int rows = graph.length;
        int cols = graph[0].length;
        // STEP ONE : MAKING GRAPH (ADJACENCY LIST)
        HashMap<Integer, HashSet<Integer>> g = new HashMap<>();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                g.putIfAbsent(i, new HashSet<>());
                g.putIfAbsent(j, new HashSet<>());
                if (i != j && graph[i][j] == 1) {
                    g.get(i).add(j);
                    g.get(j).add(i);
                }
            }
        }
        // STEP TWO : COLORING EVERY NODES
        int[] color = new int[rows];
        Arrays.fill(color, -1);
        int c = 0;
        for (int i = 0; i < rows; i++) {
            if (color[i] == -1) {
                // if not colored alreay,we do dfs
                dfsHelper(g, color, i, c++);
            }
        }
        System.out.println(Arrays.toString(color));
        // STEP THREE : TRACKING THE SIZE OF EACH COLOR
        int[] csize = new int[c];
        for (int col : color) {
            csize[col] += 1;
        }
        System.out.println(Arrays.toString(csize));
        // STEP FOUR : TRACKING UNIQUE COLORS
        int[] colorCount = new int[c];
        for (int node : initial) {
            colorCount[color[node]]++;
        }
        System.out.println(Arrays.toString(colorCount));
        // STEP FIVE : DETERMINING THE ANSWER
        int ans = Integer.MAX_VALUE;
        for (int node : initial) {
            int col = color[node];
            if (colorCount[col] == 1) {
                if (ans == Integer.MAX_VALUE)
                    ans = node;
                else if (csize[col] > csize[color[ans]])
                    ans = node;
                else if (csize[col] == csize[color[ans]] && node < ans)
                    ans = node;
            }
        }
        if (ans == Integer.MAX_VALUE) {
            for (int node : initial) {
                ans = Math.min(ans, node);
            }
        }
        return ans;
    }

    private void dfsHelper(HashMap<Integer, HashSet<Integer>> g, int[] color, int curr, int id) {
        // gotta do a DFS coloring
        color[curr] = id;
        for (int next : g.get(curr)) {
            if (color[next] == -1) {
                // means uncolored and unvisited
                dfsHelper(g, color, next, id);
            }
        }
    }

    public static void main(String[] args) {
        MinimizeMalwareSpread obj = new MinimizeMalwareSpread();
        int[][] graph = {
                { 1, 1, 0 }, { 1, 1, 0 }, { 0, 0, 1 }
        };
        int[] initial = { 0, 1 };
        System.out.println(obj.minMalwareSpread(graph, initial));
    }
}
